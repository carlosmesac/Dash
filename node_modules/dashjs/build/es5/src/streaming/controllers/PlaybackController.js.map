{"version":3,"sources":["../../../../../src/streaming/controllers/PlaybackController.js"],"names":["LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS","PlaybackController","context","eventBus","getInstance","instance","logger","streamController","dashMetrics","adapter","videoModel","timelineConverter","liveStartTime","wallclockTimeIntervalId","earliestTime","liveDelay","bufferedRange","streamInfo","isDynamic","mediaPlayerModel","playOnceInitialized","lastLivePlaybackTime","availabilityStartTime","compatibleWithPreviousStream","isLowLatencySeekingInProgress","playbackStalled","minPlaybackRateChange","uriFragmentModel","settings","setup","getLogger","reset","initialize","StreamInfo","compatible","addAllListeners","manifestInfo","start","ua","navigator","userAgent","toLowerCase","isSafari","test","on","Events","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","BUFFER_CLEARED","onBufferCleared","LOADING_PROGRESS","onFragmentLoadProgress","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","PERIOD_SWITCH_STARTED","onPeriodSwitchStarted","PLAYBACK_PROGRESS","onPlaybackProgression","PLAYBACK_TIME_UPDATED","PLAYBACK_ENDED","onPlaybackEnded","STREAM_INITIALIZING","onStreamInitializing","play","e","fromStreamInfo","id","undefined","getTimeToStreamEnd","parseFloat","getStreamEndTime","getTime","toFixed","startTime","getStreamStartTime","offset","duration","getElement","isPaused","pause","isSeeking","seek","time","stickToBuffered","internalSeek","removeEventListener","onPlaybackSeeking","info","setCurrentTime","trigger","PLAYBACK_SEEK_ASKED","seekToLive","DVRMetrics","getCurrentDVRInfo","DVRWindow","range","end","getLiveDelay","getNormalizedTime","t","isNaN","timeOffset","getPlaybackRate","getPlayedRanges","getEnded","getIsDynamic","getStreamController","setLiveStartTime","value","getLiveStartTime","computeLiveDelay","fragmentDuration","dvrWindowSize","delay","ret","r","END_OF_PLAYLIST_PADDING","uriParameters","getURIFragmentData","parseInt","suggestedPresentationDelay","getSuggestedPresentationDelay","get","streaming","useSuggestedPresentationDelay","lowLatencyEnabled","liveDelayFragmentCount","minBufferTime","getAvailabilityStartTime","targetDelayCapping","Math","max","min","getCurrentLiveLatency","NaN","currentTime","now","Date","getClientTimeOffset","off","stopUpdatingWallclockTime","removeAllListeners","setConfig","config","getStartTimeFromUriParameters","fragData","DVRWindowSize","floor","availableFrom","fragS","s","fragT","ignoreStartOffset","liveEdge","presentationStartTime","startTimeOffset","currentEarliestTime","audio","video","getActualPresentationTime","actualTime","abs","startUpdatingWallclockTime","tick","onWallclockTime","setInterval","wallclockTimeUpdateInterval","clearInterval","updateCurrentTime","getReadyState","timeChanged","error","representationInfo","convertDataToRepresentationInfo","currentRepresentation","mediaInfo","onCanPlay","CAN_PLAY","onPlaybackStart","PLAYBACK_STARTED","onPlaybackWaiting","PLAYBACK_WAITING","playingTime","onPlaybackPlaying","PLAYBACK_PLAYING","onPlaybackPaused","PLAYBACK_PAUSED","ended","seekTime","PLAYBACK_SEEKING","onPlaybackSeeked","PLAYBACK_SEEKED","addEventListener","onPlaybackTimeUpdated","timeToEnd","updateLivePlaybackTime","onPlaybackProgress","onPlaybackRateChanged","rate","PLAYBACK_RATE_CHANGED","playbackRate","onPlaybackMetaDataLoaded","PLAYBACK_METADATA_LOADED","onNativePlaybackEnded","getActiveStreamInfo","isLast","onPlaybackError","event","target","srcElement","PLAYBACK_ERROR","WALLCLOCK_TIME_UPDATED","checkTimeInRanges","ranges","length","i","len","liveCatchUpPlaybackRate","needToCatchUp","startPlaybackCatchUp","stopPlaybackCatchUp","getBufferLevel","bufferLevel","getActiveStreamProcessors","forEach","bl","p","liveCatchUpMinDrift","cpr","deltaLatency","d","pow","E","newRate","setPlaybackRate","liveCatchUpMaxDrift","type","sender","getType","from","to","started","commonEarliestTime","initialStartTime","bufferedRanges","hasVideoTrack","isTrackTypePresent","Constants","VIDEO","hasAudioTrack","AUDIO","stream","request","minDelay","warn","update","state","MetricsConstants","BUFFER_EMPTY","setStallState","mediaType","onPlaybackStalled","PLAYBACK_STALLED","applyServiceDescription","serviceDescriptions","llsd","sd","schemeIdUri","SERVICE_DESCRIPTION_LL_SCHEME","supplementalProperties","SUPPLEMENTAL_PROPERTY_LL_SCHEME","latency","debug","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"PlaybackController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nconst LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS = 500;\n\nfunction PlaybackController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        streamController,\n        dashMetrics,\n        adapter,\n        videoModel,\n        timelineConverter,\n        liveStartTime,\n        wallclockTimeIntervalId,\n        earliestTime,\n        liveDelay,\n        bufferedRange,\n        streamInfo,\n        isDynamic,\n        mediaPlayerModel,\n        playOnceInitialized,\n        lastLivePlaybackTime,\n        availabilityStartTime,\n        compatibleWithPreviousStream,\n        isLowLatencySeekingInProgress,\n        playbackStalled,\n        minPlaybackRateChange,\n        uriFragmentModel,\n        settings;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        reset();\n    }\n\n    function initialize(StreamInfo, compatible) {\n        streamInfo = StreamInfo;\n        addAllListeners();\n        isDynamic = streamInfo.manifestInfo.isDynamic;\n        isLowLatencySeekingInProgress = false;\n        playbackStalled = false;\n        liveStartTime = streamInfo.start;\n        compatibleWithPreviousStream = compatible;\n\n        const ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';\n\n        // Detect safari browser (special behavior for low latency streams)\n        const isSafari = /safari/.test(ua) && !/chrome/.test(ua);\n        minPlaybackRateChange = isSafari ? 0.25 : 0.02;\n\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n        eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, this);\n        eventBus.on(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_ENDED, onPlaybackEnded, this);\n        eventBus.on(Events.STREAM_INITIALIZING, onStreamInitializing, this);\n\n        if (playOnceInitialized) {\n            playOnceInitialized = false;\n            play();\n        }\n    }\n\n    function onPeriodSwitchStarted(e) {\n        if (!isDynamic && e.fromStreamInfo && earliestTime[e.fromStreamInfo.id] !== undefined) {\n            delete bufferedRange[e.fromStreamInfo.id];\n            delete earliestTime[e.fromStreamInfo.id];\n        }\n    }\n\n    function getTimeToStreamEnd() {\n        return parseFloat((getStreamEndTime() - getTime()).toFixed(5));\n    }\n\n    function getStreamEndTime() {\n        const startTime = getStreamStartTime(true);\n        const offset = isDynamic && streamInfo ? startTime - streamInfo.start : 0;\n        return startTime + (streamInfo ? streamInfo.duration - offset : offset);\n    }\n\n    function play() {\n        if (streamInfo && videoModel && videoModel.getElement()) {\n            videoModel.play();\n        } else {\n            playOnceInitialized = true;\n        }\n    }\n\n    function isPaused() {\n        return streamInfo && videoModel ? videoModel.isPaused() : null;\n    }\n\n    function pause() {\n        if (streamInfo && videoModel) {\n            videoModel.pause();\n        }\n    }\n\n    function isSeeking() {\n        return streamInfo && videoModel ? videoModel.isSeeking() : null;\n    }\n\n    function seek(time, stickToBuffered, internalSeek) {\n        if (streamInfo && videoModel) {\n            if (internalSeek === true) {\n                if (time !== videoModel.getTime()) {\n                    // Internal seek = seek video model only (disable 'seeking' listener),\n                    // buffer(s) are already appended at given time (see onBytesAppended())\n                    videoModel.removeEventListener('seeking', onPlaybackSeeking);\n                    logger.info('Requesting internal seek to time: ' + time);\n                    videoModel.setCurrentTime(time, stickToBuffered);\n                }\n            } else {\n                eventBus.trigger(Events.PLAYBACK_SEEK_ASKED);\n                logger.info('Requesting seek to time: ' + time);\n                videoModel.setCurrentTime(time, stickToBuffered);\n            }\n        }\n    }\n\n    function seekToLive() {\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo();\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n\n        seek(DVRWindow.end - mediaPlayerModel.getLiveDelay(), true, false);\n    }\n\n    function getTime() {\n        return streamInfo && videoModel ? videoModel.getTime() : null;\n    }\n\n    function getNormalizedTime() {\n        let t = getTime();\n\n        if (isDynamic && !isNaN(availabilityStartTime)) {\n            const timeOffset = availabilityStartTime / 1000;\n            // Fix current time for firefox and safari (returned as an absolute time)\n            if (t > timeOffset) {\n                t -= timeOffset;\n            }\n        }\n\n        return t;\n    }\n\n    function getPlaybackRate() {\n        return streamInfo && videoModel ? videoModel.getPlaybackRate() : null;\n    }\n\n    function getPlayedRanges() {\n        return streamInfo && videoModel ? videoModel.getPlayedRanges() : null;\n    }\n\n    function getEnded() {\n        return streamInfo && videoModel ? videoModel.getEnded() : null;\n    }\n\n    function getIsDynamic() {\n        return isDynamic;\n    }\n\n    function getStreamController() {\n        return streamController;\n    }\n\n    function setLiveStartTime(value) {\n        liveStartTime = value;\n    }\n\n    function getLiveStartTime() {\n        return liveStartTime;\n    }\n\n    /**\n     * Computes the desirable delay for the live edge to avoid a risk of getting 404 when playing at the bleeding edge\n     * @param {number} fragmentDuration - seconds?\n     * @param {number} dvrWindowSize - seconds?\n     * @returns {number} object\n     * @memberof PlaybackController#\n     */\n    function computeLiveDelay(fragmentDuration, dvrWindowSize) {\n        let delay,\n            ret,\n            r,\n            startTime;\n        const END_OF_PLAYLIST_PADDING = 10;\n\n        let uriParameters = uriFragmentModel.getURIFragmentData();\n\n        if (uriParameters) {\n            r = parseInt(uriParameters.r, 10);\n        }\n\n        let suggestedPresentationDelay = adapter.getSuggestedPresentationDelay();\n\n        if (settings.get().streaming.useSuggestedPresentationDelay && suggestedPresentationDelay !== null) {\n            delay = suggestedPresentationDelay;\n        } else if (settings.get().streaming.lowLatencyEnabled) {\n            delay = 0;\n        } else if (mediaPlayerModel.getLiveDelay()) {\n            delay = mediaPlayerModel.getLiveDelay(); // If set by user, this value takes precedence\n        } else if (r) {\n            delay = r;\n        }\n        else if (!isNaN(fragmentDuration)) {\n            delay = fragmentDuration * settings.get().streaming.liveDelayFragmentCount;\n        } else {\n            delay = streamInfo.manifestInfo.minBufferTime * 2;\n        }\n\n        startTime = adapter.getAvailabilityStartTime();\n\n        if (startTime !== null) {\n            availabilityStartTime = startTime;\n        }\n\n        if (dvrWindowSize > 0) {\n            // cap target latency to:\n            // - dvrWindowSize / 2 for short playlists\n            // - dvrWindowSize - END_OF_PLAYLIST_PADDING for longer playlists\n            const targetDelayCapping = Math.max(dvrWindowSize - END_OF_PLAYLIST_PADDING, dvrWindowSize / 2);\n            ret = Math.min(delay, targetDelayCapping);\n        } else {\n            ret = delay;\n        }\n        liveDelay = ret;\n        return ret;\n    }\n\n    function getLiveDelay() {\n        return liveDelay;\n    }\n\n    function getCurrentLiveLatency() {\n        if (!isDynamic || isNaN(availabilityStartTime)) {\n            return NaN;\n        }\n        let currentTime = getNormalizedTime();\n        if (isNaN(currentTime) || currentTime === 0) {\n            return 0;\n        }\n\n        const now = new Date().getTime() + timelineConverter.getClientTimeOffset() * 1000;\n        return Math.max(((now - availabilityStartTime - currentTime * 1000) / 1000).toFixed(3), 0);\n    }\n\n    function reset() {\n        liveStartTime = NaN;\n        playOnceInitialized = false;\n        earliestTime = {};\n        liveDelay = 0;\n        availabilityStartTime = 0;\n        bufferedRange = {};\n        if (videoModel) {\n            eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n            eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n            eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n            eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n            eventBus.off(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, this);\n            eventBus.off(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n            eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n            eventBus.off(Events.PLAYBACK_ENDED, onPlaybackEnded, this);\n            eventBus.off(Events.STREAM_INITIALIZING, onStreamInitializing, this);\n            eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, this);\n            stopUpdatingWallclockTime();\n            removeAllListeners();\n        }\n        wallclockTimeIntervalId = null;\n        videoModel = null;\n        streamInfo = null;\n        isDynamic = null;\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.timelineConverter) {\n            timelineConverter = config.timelineConverter;\n        }\n        if (config.uriFragmentModel) {\n            uriFragmentModel = config.uriFragmentModel;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function getStartTimeFromUriParameters() {\n        const fragData = uriFragmentModel.getURIFragmentData();\n        let uriParameters;\n        if (fragData) {\n            uriParameters = {};\n            const r = parseInt(fragData.r, 10);\n            if (r >= 0 && streamInfo && r < streamInfo.manifestInfo.DVRWindowSize && fragData.t === null) {\n                fragData.t = Math.max(Math.floor(Date.now() / 1000) - streamInfo.manifestInfo.DVRWindowSize, (streamInfo.manifestInfo.availableFrom.getTime() / 1000) + streamInfo.start) + r;\n            }\n            uriParameters.fragS = parseFloat(fragData.s);\n            uriParameters.fragT = parseFloat(fragData.t);\n        }\n        return uriParameters;\n    }\n\n    /**\n     * @param {boolean} ignoreStartOffset - ignore URL fragment start offset if true\n     * @param {number} liveEdge - liveEdge value\n     * @returns {number} object\n     * @memberof PlaybackController#\n     */\n    function getStreamStartTime(ignoreStartOffset, liveEdge) {\n        let presentationStartTime;\n        let startTimeOffset = NaN;\n\n        if (!ignoreStartOffset) {\n            const uriParameters = getStartTimeFromUriParameters();\n            if (uriParameters) {\n                startTimeOffset = !isNaN(uriParameters.fragS) ? uriParameters.fragS : uriParameters.fragT;\n            } else {\n                startTimeOffset = 0;\n            }\n        } else {\n            startTimeOffset = streamInfo ? streamInfo.start : startTimeOffset;\n        }\n\n        if (isDynamic) {\n            if (!isNaN(startTimeOffset) && streamInfo) {\n                presentationStartTime = startTimeOffset - (streamInfo.manifestInfo.availableFrom.getTime() / 1000);\n\n                if (presentationStartTime > liveStartTime ||\n                    presentationStartTime < (!isNaN(liveEdge) ? (liveEdge - streamInfo.manifestInfo.DVRWindowSize) : NaN)) {\n                    presentationStartTime = null;\n                }\n            }\n            presentationStartTime = presentationStartTime || liveStartTime;\n\n        } else {\n            if (streamInfo) {\n                if (!isNaN(startTimeOffset) && startTimeOffset < Math.max(streamInfo.manifestInfo.duration, streamInfo.duration) && startTimeOffset >= 0) {\n                    presentationStartTime = startTimeOffset;\n                } else {\n                    let currentEarliestTime = earliestTime[streamInfo.id]; //set by ready bufferStart after first onBytesAppended\n                    presentationStartTime = currentEarliestTime !== undefined ? Math.max(currentEarliestTime.audio !== undefined ? currentEarliestTime.audio : 0, currentEarliestTime.video !== undefined ? currentEarliestTime.video : 0, streamInfo.start) : streamInfo.start;\n                }\n            }\n        }\n\n        return presentationStartTime;\n    }\n\n    function getActualPresentationTime(currentTime) {\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo();\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n        let actualTime;\n\n        if (!DVRWindow) {\n            return NaN;\n        }\n        if (currentTime > DVRWindow.end) {\n            actualTime = Math.max(DVRWindow.end - streamInfo.manifestInfo.minBufferTime * 2, DVRWindow.start);\n\n        } else if (currentTime > 0 && currentTime + 0.250 < DVRWindow.start && Math.abs(currentTime - DVRWindow.start) < 315360000) {\n\n            // Checking currentTime plus 250ms as the 'timeupdate' is fired with a frequency between 4Hz and 66Hz\n            // https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate\n            // http://w3c.github.io/html/single-page.html#offsets-into-the-media-resource\n            // Checking also duration of the DVR makes sense. We detected temporary situations in which currentTime\n            // is bad reported by the browser which causes playback to jump to start (315360000 = 1 year)\n            actualTime = DVRWindow.start;\n        } else {\n            actualTime = currentTime;\n        }\n\n        return actualTime;\n    }\n\n    function startUpdatingWallclockTime() {\n        if (wallclockTimeIntervalId !== null) return;\n\n        const tick = function () {\n            onWallclockTime();\n        };\n\n        wallclockTimeIntervalId = setInterval(tick, settings.get().streaming.wallclockTimeUpdateInterval);\n    }\n\n    function stopUpdatingWallclockTime() {\n        clearInterval(wallclockTimeIntervalId);\n        wallclockTimeIntervalId = null;\n    }\n\n    function updateCurrentTime() {\n        if (isPaused() || !isDynamic || videoModel.getReadyState() === 0) return;\n        const currentTime = getNormalizedTime();\n        const actualTime = getActualPresentationTime(currentTime);\n\n        const timeChanged = (!isNaN(actualTime) && actualTime !== currentTime);\n        if (timeChanged) {\n            seek(actualTime);\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.error) return;\n\n        const representationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\n        const info = representationInfo ? representationInfo.mediaInfo.streamInfo : null;\n\n        if (info === null || streamInfo.id !== info.id) return;\n        streamInfo = info;\n\n        updateCurrentTime();\n    }\n\n    function onCanPlay() {\n        eventBus.trigger(Events.CAN_PLAY);\n    }\n\n    function onPlaybackStart() {\n        logger.info('Native video element event: play');\n        updateCurrentTime();\n        startUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_STARTED, {\n            startTime: getTime()\n        });\n    }\n\n    function onPlaybackWaiting() {\n        logger.info('Native video element event: waiting');\n        eventBus.trigger(Events.PLAYBACK_WAITING, {\n            playingTime: getTime()\n        });\n    }\n\n    function onPlaybackPlaying() {\n        logger.info('Native video element event: playing');\n        eventBus.trigger(Events.PLAYBACK_PLAYING, {\n            playingTime: getTime()\n        });\n    }\n\n    function onPlaybackPaused() {\n        logger.info('Native video element event: pause');\n        eventBus.trigger(Events.PLAYBACK_PAUSED, {\n            ended: getEnded()\n        });\n    }\n\n    function onPlaybackSeeking() {\n        const seekTime = getTime();\n        logger.info('Seeking to: ' + seekTime);\n        startUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_SEEKING, {\n            seekTime: seekTime\n        });\n    }\n\n    function onPlaybackSeeked() {\n        logger.info('Native video element event: seeked');\n        eventBus.trigger(Events.PLAYBACK_SEEKED);\n        // Reactivate 'seeking' event listener (see seek())\n        videoModel.addEventListener('seeking', onPlaybackSeeking);\n    }\n\n    function onPlaybackTimeUpdated() {\n        if (streamInfo) {\n            eventBus.trigger(Events.PLAYBACK_TIME_UPDATED, {\n                timeToEnd: getTimeToStreamEnd(),\n                time: getTime()\n            });\n        }\n    }\n\n    function updateLivePlaybackTime() {\n        const now = Date.now();\n        if (!lastLivePlaybackTime || now > lastLivePlaybackTime + LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS) {\n            lastLivePlaybackTime = now;\n            onPlaybackTimeUpdated();\n        }\n    }\n\n    function onPlaybackProgress() {\n        eventBus.trigger(Events.PLAYBACK_PROGRESS);\n    }\n\n    function onPlaybackRateChanged() {\n        const rate = getPlaybackRate();\n        logger.info('Native video element event: ratechange: ', rate);\n        eventBus.trigger(Events.PLAYBACK_RATE_CHANGED, {\n            playbackRate: rate\n        });\n    }\n\n    function onPlaybackMetaDataLoaded() {\n        logger.info('Native video element event: loadedmetadata');\n        eventBus.trigger(Events.PLAYBACK_METADATA_LOADED);\n        startUpdatingWallclockTime();\n    }\n\n    // Event to handle the native video element ended event\n    function onNativePlaybackEnded() {\n        logger.info('Native video element event: ended');\n        pause();\n        stopUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_ENDED, {'isLast': streamController.getActiveStreamInfo().isLast});\n    }\n\n    // Handle DASH PLAYBACK_ENDED event\n    function onPlaybackEnded(e) {\n        if (wallclockTimeIntervalId && e.isLast) {\n            // PLAYBACK_ENDED was triggered elsewhere, react.\n            logger.info('onPlaybackEnded -- PLAYBACK_ENDED but native video element didn\\'t fire ended');\n            videoModel.setCurrentTime(getStreamEndTime());\n            pause();\n            stopUpdatingWallclockTime();\n        }\n    }\n\n    function onPlaybackError(event) {\n        const target = event.target || event.srcElement;\n        eventBus.trigger(Events.PLAYBACK_ERROR, {\n            error: target.error\n        });\n    }\n\n    function onWallclockTime() {\n        eventBus.trigger(Events.WALLCLOCK_TIME_UPDATED, {\n            isDynamic: isDynamic,\n            time: new Date()\n        });\n\n        // Updates playback time for paused dynamic streams\n        // (video element doesn't call timeupdate when the playback is paused)\n        if (getIsDynamic() && isPaused()) {\n            updateLivePlaybackTime();\n        }\n    }\n\n    function checkTimeInRanges(time, ranges) {\n        if (ranges && ranges.length > 0) {\n            for (let i = 0, len = ranges.length; i < len; i++) {\n                if (time >= ranges.start(i) && time < ranges.end(i)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function onPlaybackProgression() {\n        if (\n            isDynamic &&\n            settings.get().streaming.lowLatencyEnabled &&\n            settings.get().streaming.liveCatchUpPlaybackRate > 0 &&\n            !isPaused() &&\n            !isSeeking()\n        ) {\n            if (needToCatchUp()) {\n                startPlaybackCatchUp();\n            } else {\n                stopPlaybackCatchUp();\n            }\n        }\n    }\n\n    function getBufferLevel() {\n        let bufferLevel = null;\n        streamController.getActiveStreamProcessors().forEach(p => {\n            const bl = p.getBufferLevel();\n            if (bufferLevel === null) {\n                bufferLevel = bl;\n            } else {\n                bufferLevel = Math.min(bufferLevel, bl);\n            }\n        });\n\n        return bufferLevel;\n    }\n\n    function needToCatchUp() {\n        return settings.get().streaming.liveCatchUpPlaybackRate > 0 && getTime() > 0 &&\n            Math.abs(getCurrentLiveLatency() - mediaPlayerModel.getLiveDelay()) > settings.get().streaming.liveCatchUpMinDrift;\n    }\n\n    function startPlaybackCatchUp() {\n        if (videoModel) {\n            const cpr = settings.get().streaming.liveCatchUpPlaybackRate;\n            const liveDelay = mediaPlayerModel.getLiveDelay();\n            const deltaLatency = getCurrentLiveLatency() - liveDelay;\n            const d = deltaLatency * 5;\n            // Playback rate must be between (1 - cpr) - (1 + cpr)\n            // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n            const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\n            let newRate = (1 - cpr) + s;\n            // take into account situations in which there are buffer stalls,\n            // in which increasing playbackRate to reach target latency will\n            // just cause more and more stall situations\n            if (playbackStalled) {\n                const bufferLevel = getBufferLevel();\n                if (bufferLevel > liveDelay / 2) {\n                    playbackStalled = false;\n                } else if (deltaLatency > 0) {\n                    newRate = 1.0;\n                }\n            }\n\n            // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n            if (Math.abs(videoModel.getPlaybackRate() - newRate) > minPlaybackRateChange) {\n                videoModel.setPlaybackRate(newRate);\n            }\n\n            if (settings.get().streaming.liveCatchUpMaxDrift > 0 && !isLowLatencySeekingInProgress &&\n                deltaLatency > settings.get().streaming.liveCatchUpMaxDrift) {\n                logger.info('Low Latency catchup mechanism. Latency too high, doing a seek to live point');\n                isLowLatencySeekingInProgress = true;\n                seekToLive();\n            } else {\n                isLowLatencySeekingInProgress = false;\n            }\n        }\n    }\n\n    function stopPlaybackCatchUp() {\n        if (videoModel) {\n            videoModel.setPlaybackRate(1.0);\n        }\n    }\n\n    function onBufferCleared(e) {\n        const type = e.sender.getType();\n\n        if (streamInfo && earliestTime[streamInfo.id] && (earliestTime[streamInfo.id][type] >= e.from && earliestTime[streamInfo.id][type] <= e.to)) {\n            logger.info('Reset commonEarliestTime and bufferedRange for ' + type);\n            bufferedRange[streamInfo.id][type] = undefined;\n            earliestTime[streamInfo.id][type] = undefined;\n            earliestTime[streamInfo.id].started = false;\n        } else {\n            logger.info('No need to reset commonEarliestTime and bufferedRange for ' + type);\n        }\n    }\n\n    function onBytesAppended(e) {\n        let commonEarliestTime,\n            initialStartTime;\n        let ranges = e.bufferedRanges;\n        if (!ranges || !ranges.length) return;\n        if (earliestTime[streamInfo.id] && earliestTime[streamInfo.id].started === true) {\n            //stream has already been started.\n            return;\n        }\n\n        const type = e.sender.getType();\n\n        if (bufferedRange[streamInfo.id] === undefined) {\n            bufferedRange[streamInfo.id] = [];\n        }\n\n        bufferedRange[streamInfo.id][type] = ranges;\n\n        if (earliestTime[streamInfo.id] === undefined) {\n            earliestTime[streamInfo.id] = [];\n            earliestTime[streamInfo.id].started = false;\n        }\n\n        if (earliestTime[streamInfo.id][type] === undefined) {\n            earliestTime[streamInfo.id][type] = Math.max(ranges.start(0), streamInfo.start);\n        }\n\n        const hasVideoTrack = streamController.isTrackTypePresent(Constants.VIDEO);\n        const hasAudioTrack = streamController.isTrackTypePresent(Constants.AUDIO);\n\n        initialStartTime = getStreamStartTime(false);\n        if (hasAudioTrack && hasVideoTrack) {\n            //current stream has audio and video contents\n            if (!isNaN(earliestTime[streamInfo.id].audio) && !isNaN(earliestTime[streamInfo.id].video)) {\n\n                if (earliestTime[streamInfo.id].audio < earliestTime[streamInfo.id].video) {\n                    // common earliest is video time\n                    // check buffered audio range has video time, if ok, we seek, otherwise, we wait some other data\n                    commonEarliestTime = earliestTime[streamInfo.id].video > initialStartTime ? earliestTime[streamInfo.id].video : initialStartTime;\n                    ranges = bufferedRange[streamInfo.id].audio;\n                } else {\n                    // common earliest is audio time\n                    // check buffered video range has audio time, if ok, we seek, otherwise, we wait some other data\n                    commonEarliestTime = earliestTime[streamInfo.id].audio > initialStartTime ? earliestTime[streamInfo.id].audio : initialStartTime;\n                    ranges = bufferedRange[streamInfo.id].video;\n                }\n                if (checkTimeInRanges(commonEarliestTime, ranges)) {\n                    if (!(checkTimeInRanges(getNormalizedTime(), bufferedRange[streamInfo.id].audio) && checkTimeInRanges(getNormalizedTime(), bufferedRange[streamInfo.id].video))) {\n                        if (!compatibleWithPreviousStream && commonEarliestTime !== 0) {\n                            seek(commonEarliestTime, true, true);\n                        }\n                    }\n                    earliestTime[streamInfo.id].started = true;\n                }\n            }\n        } else {\n            //current stream has only audio or only video content\n            if (earliestTime[streamInfo.id][type]) {\n                commonEarliestTime = earliestTime[streamInfo.id][type] > initialStartTime ? earliestTime[streamInfo.id][type] : initialStartTime;\n                if (!compatibleWithPreviousStream) {\n                    seek(commonEarliestTime, false, true);\n                }\n                earliestTime[streamInfo.id].started = true;\n            }\n        }\n    }\n\n    function onFragmentLoadProgress(e) {\n        // If using fetch and stream mode is not available, readjust live latency so it is 20% higher than segment duration\n        if (e.stream === false && settings.get().streaming.lowLatencyEnabled && !isNaN(e.request.duration)) {\n            const minDelay = 1.2 * e.request.duration;\n            if (minDelay > mediaPlayerModel.getLiveDelay()) {\n                logger.warn('Browser does not support fetch API with StreamReader. Increasing live delay to be 20% higher than segment duration:', minDelay.toFixed(2));\n                const s = { streaming: { liveDelay: minDelay } };\n                settings.update(s);\n            }\n        }\n    }\n\n    function onBufferLevelStateChanged(e) {\n        // do not stall playback when get an event from Stream that is not active\n        if (e.streamInfo.id !== streamInfo.id) return;\n\n        if (settings.get().streaming.lowLatencyEnabled) {\n            if (e.state === MetricsConstants.BUFFER_EMPTY && !isSeeking()) {\n                if (!playbackStalled) {\n                    playbackStalled = true;\n                    stopPlaybackCatchUp();\n                }\n            }\n        } else {\n            videoModel.setStallState(e.mediaType, e.state === MetricsConstants.BUFFER_EMPTY);\n        }\n    }\n\n    function onPlaybackStalled(e) {\n        eventBus.trigger(Events.PLAYBACK_STALLED, {\n            e: e\n        });\n    }\n\n    function onStreamInitializing(e) {\n        applyServiceDescription(e.streamInfo, e.mediaInfo);\n    }\n\n    function applyServiceDescription(streamInfo, mediaInfo) {\n        if (streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.serviceDescriptions) {\n            // is there a service description for low latency defined?\n            let llsd;\n\n            for (let i = 0; i < streamInfo.manifestInfo.serviceDescriptions.length; i++) {\n                const sd = streamInfo.manifestInfo.serviceDescriptions[i];\n                if (sd.schemeIdUri === Constants.SERVICE_DESCRIPTION_LL_SCHEME) {\n                    llsd = sd;\n                    break;\n                }\n            }\n\n            if (llsd) {\n                if (mediaInfo && mediaInfo.supplementalProperties &&\n                    mediaInfo.supplementalProperties[Constants.SUPPLEMENTAL_PROPERTY_LL_SCHEME] === 'true') {\n                    if (llsd.latency && llsd.latency.target > 0) {\n                        logger.debug('Apply LL properties coming from service description. Target Latency (ms):', llsd.latency.target);\n                        settings.update({\n                            streaming: {\n                                lowLatencyEnabled: true,\n                                liveDelay: llsd.latency.target / 1000,\n                                liveCatchUpMinDrift: llsd.latency.max > llsd.latency.target ? (llsd.latency.max - llsd.latency.target) / 1000 : undefined\n                            }\n                        });\n                    }\n                    if (llsd.playbackRate && llsd.playbackRate.max > 1.0) {\n                        logger.debug('Apply LL properties coming from service description. Max PlaybackRate:', llsd.playbackRate.max);\n                        settings.update({\n                            streaming: {\n                                lowLatencyEnabled: true,\n                                liveCatchUpPlaybackRate: llsd.playbackRate.max - 1.0\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    function addAllListeners() {\n        videoModel.addEventListener('canplay', onCanPlay);\n        videoModel.addEventListener('play', onPlaybackStart);\n        videoModel.addEventListener('waiting', onPlaybackWaiting);\n        videoModel.addEventListener('playing', onPlaybackPlaying);\n        videoModel.addEventListener('pause', onPlaybackPaused);\n        videoModel.addEventListener('error', onPlaybackError);\n        videoModel.addEventListener('seeking', onPlaybackSeeking);\n        videoModel.addEventListener('seeked', onPlaybackSeeked);\n        videoModel.addEventListener('timeupdate', onPlaybackTimeUpdated);\n        videoModel.addEventListener('progress', onPlaybackProgress);\n        videoModel.addEventListener('ratechange', onPlaybackRateChanged);\n        videoModel.addEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n        videoModel.addEventListener('stalled', onPlaybackStalled);\n        videoModel.addEventListener('ended', onNativePlaybackEnded);\n    }\n\n    function removeAllListeners() {\n        videoModel.removeEventListener('canplay', onCanPlay);\n        videoModel.removeEventListener('play', onPlaybackStart);\n        videoModel.removeEventListener('waiting', onPlaybackWaiting);\n        videoModel.removeEventListener('playing', onPlaybackPlaying);\n        videoModel.removeEventListener('pause', onPlaybackPaused);\n        videoModel.removeEventListener('error', onPlaybackError);\n        videoModel.removeEventListener('seeking', onPlaybackSeeking);\n        videoModel.removeEventListener('seeked', onPlaybackSeeked);\n        videoModel.removeEventListener('timeupdate', onPlaybackTimeUpdated);\n        videoModel.removeEventListener('progress', onPlaybackProgress);\n        videoModel.removeEventListener('ratechange', onPlaybackRateChanged);\n        videoModel.removeEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n        videoModel.removeEventListener('stalled', onPlaybackStalled);\n        videoModel.removeEventListener('ended', onNativePlaybackEnded);\n    }\n\n    instance = {\n        initialize: initialize,\n        setConfig: setConfig,\n        getStartTimeFromUriParameters: getStartTimeFromUriParameters,\n        getStreamStartTime: getStreamStartTime,\n        getTimeToStreamEnd: getTimeToStreamEnd,\n        getTime: getTime,\n        getNormalizedTime: getNormalizedTime,\n        getPlaybackRate: getPlaybackRate,\n        getPlayedRanges: getPlayedRanges,\n        getEnded: getEnded,\n        getIsDynamic: getIsDynamic,\n        getStreamController: getStreamController,\n        setLiveStartTime: setLiveStartTime,\n        getLiveStartTime: getLiveStartTime,\n        computeLiveDelay: computeLiveDelay,\n        getLiveDelay: getLiveDelay,\n        getCurrentLiveLatency: getCurrentLiveLatency,\n        play: play,\n        isPaused: isPaused,\n        pause: pause,\n        isSeeking: isSeeking,\n        seek: seek,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nPlaybackController.__dashjs_factory_name = 'PlaybackController';\nexport default FactoryMaker.getSingletonFactory(PlaybackController);\n"]}